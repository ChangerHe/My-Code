<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
		
		// /1.使用JSON创建一个员工对象（要求有姓名、年龄、部门和爱好）
		var staff = {
			name: 'ChangerHe',
			age: 18,
			hobby: 'running'
		}

		// 22.简述JS编译器执行的原理
		/*
			现在的前后端开发语言主要有两大类,一个是编译型语言,一个是解释型语言.

			对应的,对于静态语言来说,如 JAVA C C++ 处理这些事情的脚编译器,相对应的,对于javascript这样的语言则叫解释器,这两者的区别在于

			编译器是将源代码编译为另外一种代码,而解释器是直接解析并将代码运行结果输出

			所以当javascript引擎解析脚本的时候,是有预编译和解释执行两个阶段的

			在预编译阶段,引擎会创建一个执行的上下文对象,同时,对于函数来说,因为在ES5中,javascript仅有函数作用域而没有块级作用域,所以的话,当执行到函数的时候,解释器会将函数的作用域,或者说是执行上下文进行压栈处理,也就是将该函数的执行上下文压到栈顶,让其先执行

			当然,在这其中,预编译阶段会存在一个变量和函数声明的提升过程,在这个过程中

			首先,编译器会将函数声明提升到作用域的顶端

			然后将变量的定义,也就是  var出来的变量先提升到作用域的顶端,但是并不会马上对其赋值


		*/

		//3.简述常见的两种作用域
		/*
			全局作用域: 定义于全局, 也就是挂靠在window下面的对象

			局部作用域: 在ES5之前,因为javascript没有块级作用域这个概念,所以局部作用域其实就是函数的作用域.

			在ES6中,我们使用let 或 const 来定义变量,可以生成相应的局部作用域
		*/

		//4.使用递归来完成一个阶加函数
		function add(num) {
			if(num > 0) {
				return num + add(num-1)
			} else {
				return 0
			}
		}
		console.log(add(10));


		//5.利用闭包解决循环的作用域问题
		for (var i = 0; i < 10; i++) {
			!function(i){
				console.log(i);
			}(i)
		}

		// 6.作用域练习：
			// 1
		var a = 100;
		(function(){
			console.log(a);
			a = 10;
		})();

			// 2
		a = 100;
		(function(){
			console.log(a);
			// var a = 10;
		})();

			// 3
		a = 100;
		var x = {}

		x.a = (function(a){
			console.log(a);
			x.a = function(a) {
				console.log(a);
			}
			console.log(x.a);
			x.a(a)
			a = 10;
		})(a);

		console.log(x.a);
		// x.a(a);
		// x.a;
		// console.log(x.b());

			// 4
		a = 100;
		(function(a){
			console.log(a);
			var a = 10;
		})(a);

		//1）什么是闭包（closure），为什么要用它？
		/*
			闭包的最大用处还是避免全局的作用域被污染,但是闭包也存在一个问题

			因为闭包的情况下,函数内的函数会对外面的函数存在一个循环引用的关系,所以在这个情况下,javascript引擎会认为这两个函数并没有清除引用所以这个情况下, 这个闭包会常驻在内存中

			因此,在通常情况下,一般是要尽量避免使用闭包的,因为这样会产生内存泄露问题
		*/
	</script>
</body>
</html>